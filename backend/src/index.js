import express from 'express';
import cors from 'cors';
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import crypto from 'crypto';
import { execFile, spawn } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// --- Define Container Paths ---
const UPLOADS_DIR = '/usr/src/app/uploads'; // Reverted path
const DL_LIT_DIR = '/usr/src/app/dl_lit'; // Mounted from ../dl_lit
const TEMP_PAGES_BASE_DIR = path.join(DL_LIT_DIR, 'temp_pages');
const BIB_OUTPUT_DIR = path.join(DL_LIT_DIR, 'bibliographies');
const GET_BIB_PAGES_SCRIPT = path.join(DL_LIT_DIR, 'get_bib_pages.py');
const API_SCRAPER_SCRIPT = path.join(DL_LIT_DIR, 'APIscraper_v2.py'); // Updated script name

// Ensure temporary and output directories exist
fs.mkdirSync(TEMP_PAGES_BASE_DIR, { recursive: true });
fs.mkdirSync(BIB_OUTPUT_DIR, { recursive: true });
// --- End Define Container Paths ---

// Ensure uploads directory exists (already present, keeping for clarity)
const uploadDir = UPLOADS_DIR;
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

const app = express();
const port = process.env.PORT || 4000;

// Middleware
// Configure CORS to allow requests specifically from the frontend origin
const corsOptions = {
  origin: 'http://localhost:3000', // Allow the frontend host
  optionsSuccessStatus: 200 // Some legacy browsers (IE11, various SmartTVs) choke on 204
};
app.use(cors(corsOptions));
app.use(express.json());

// Configure multer for file upload
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, uniqueSuffix + '-' + file.originalname);
  }
});

const upload = multer({ storage: storage });

// --- MODIFIED ENDPOINT: Upload PDF --- 
// Renamed conceptually, but keeping path for minimal frontend changes initially
app.post('/api/process_pdf', upload.single('file'), (req, res) => { // Made non-async
  console.log('[/api/process_pdf -> /api/upload] Received upload request'); 
  try {
    console.log('[/api/upload] Inside TRY block.'); 
    if (!req.file) {
      console.log('[/api/upload] No file uploaded in request'); 
      return res.status(400).json({ error: 'No file uploaded' });
    }

    console.log('[/api/upload] req.file object:', JSON.stringify(req.file, null, 2)); 

    const storedFilename = req.file.filename; // Get filename generated by multer
    const filePath = req.file.path;
    console.log(`[/api/upload] File uploaded successfully: ${filePath}`); 
    console.log(`[/api/upload] Stored filename: ${storedFilename}`); 

    // Return the generated filename to the client
    console.log('[/api/upload] Attempting to send success response...'); 
    res.json({
      message: 'File uploaded successfully.',
      filename: storedFilename // Send back the name used on the server
    });
    console.log('[/api/upload] Success response sent.'); 

  } catch (error) {
    console.error('[/api/upload] CAUGHT ERROR in /api/process_pdf:', error); 
    // Check if response has already been sent
    if (!res.headersSent) {
      res.status(500).json({ error: 'Server error during upload', details: error.message });
    } else {
      console.error('[/api/upload] Error occurred after headers sent.');
    }
    // Attempt to clean up file if upload failed mid-request?
    if (req.file && req.file.path) {
      fs.unlink(req.file.path, (unlinkErr) => {
        if (unlinkErr) console.error('[/api/upload] Error deleting partially uploaded file:', unlinkErr);
      });
    }
  }
});
// --- END MODIFIED UPLOAD ENDPOINT --- 

// --- NEW ENDPOINT: Extract Bibliography ---
app.post('/api/extract-bibliography/:filename', (req, res) => { 
  const { filename } = req.params;
  const inputPdfPath = path.join(UPLOADS_DIR, filename);
  const uniqueSuffix = crypto.randomBytes(8).toString('hex');
  const tempPagesDir = path.join(TEMP_PAGES_BASE_DIR, `${Date.now()}-${uniqueSuffix}`);

  console.log(`[/api/extract-bibliography] Received request for: ${filename}`);
  console.log(`[/api/extract-bibliography] Input PDF path: ${inputPdfPath}`);
  console.log(`[/api/extract-bibliography] Temp pages dir: ${tempPagesDir}`);
  console.log(`[/api/extract-bibliography] Final bib output dir: ${BIB_OUTPUT_DIR}`);

  // 1. Check if input PDF exists
  if (!fs.existsSync(inputPdfPath)) {
    console.error(`[/api/extract-bibliography] Input PDF not found: ${inputPdfPath}`);
    // Return error immediately
    return res.status(404).json({ error: 'Uploaded PDF not found.' });
  }

  // --- Send Immediate Response --- 
  res.status(202).json({ message: 'Bibliography extraction process started.' }); 
  // Status 202 Accepted indicates the request is accepted for processing, but is not complete.
  // --- End Immediate Response ---

  // --- Run Scripts in Background --- 
  try {
    // 2. Create unique temporary directory for pages
    fs.mkdirSync(tempPagesDir, { recursive: true });
    console.log(`[/api/extract-bibliography] Created temp directory: ${tempPagesDir}`);

    // 3. Run get_bib_pages.py in background
    console.log(`[/api/extract-bibliography] Starting ${GET_BIB_PAGES_SCRIPT}...`);
    const getPagesArgs = [
      '--input-pdf', inputPdfPath,
      '--output-dir', tempPagesDir
    ];
    
    execFile('python3', [GET_BIB_PAGES_SCRIPT, ...getPagesArgs], (error, stdout, stderr) => {
      console.log(`[/api/extract-bibliography] ${GET_BIB_PAGES_SCRIPT} stdout:
${stdout}`);
      if (stderr) {
        console.warn(`[/api/extract-bibliography] ${GET_BIB_PAGES_SCRIPT} stderr:
${stderr}`);
      }
      
      if (error) {
        console.error(`[/api/extract-bibliography] Error executing ${GET_BIB_PAGES_SCRIPT}:`, error);
        // Clean up temp dir on error if needed?
        // fs.rm(...) 
        return; // Stop processing if first script failed
      }

      console.log(`[/api/extract-bibliography] Finished ${GET_BIB_PAGES_SCRIPT}.`);

      // 4. Run APIscraper.py in background (only if first script succeeded)
      console.log(`[/api/extract-bibliography] Starting ${API_SCRAPER_SCRIPT}...`);
      const scrapeApiArgs = [
        '--input-dir', tempPagesDir,
        '--output-dir', BIB_OUTPUT_DIR
      ];
      
      const pythonProcess = spawn('python3', [API_SCRAPER_SCRIPT, ...scrapeApiArgs]);

      // Log stdout data as it comes in
      pythonProcess.stdout.on('data', (data) => {
        console.log(`[/api/extract-bibliography] ${API_SCRAPER_SCRIPT} stdout:
${data}`);
      });

      // Log stderr data as it comes in
      pythonProcess.stderr.on('data', (data) => {
        console.error(`[/api/extract-bibliography] ${API_SCRAPER_SCRIPT} stderr:
${data}`);
      });

      // Log any spawn errors (e.g., python3 not found)
      pythonProcess.on('error', (error) => {
        console.error(`[/api/extract-bibliography] Failed to start ${API_SCRAPER_SCRIPT}:`, error);
        // Stop processing
        return; 
      });

      // Log when the script finishes
      pythonProcess.on('close', (code) => {
        if (code !== 0) {
          console.error(`[/api/extract-bibliography] ${API_SCRAPER_SCRIPT} exited with code ${code}`);
          // Stop processing
          return;
        }
        console.log(`[/api/extract-bibliography] Finished ${API_SCRAPER_SCRIPT}.`);
        console.log(`[/api/extract-bibliography] Bibliography extraction complete for ${filename}. Output in ${BIB_OUTPUT_DIR}.`);
        
        // Consider cleanup here *after* everything is done
        if (fs.existsSync(tempPagesDir)) {
          fs.rm(tempPagesDir, { recursive: true, force: true }, (err) => {
            if (err) {
              console.error(`[/api/extract-bibliography] Error deleting temp directory ${tempPagesDir} after completion:`, err);
            } else {
              console.log(`[/api/extract-bibliography] Deleted temp directory ${tempPagesDir} after completion.`);
            }
          });
        }
      }); // End APIscraper callback
    }); // End get_bib_pages callback

  } catch (error) {
    // This catch block likely only catches synchronous errors like fs.mkdirSync failure
    console.error(`[/api/extract-bibliography] Synchronous error setting up processing for ${filename}:`, error);
    // Cannot send response here as it might have already been sent.
  } 
  // Removed Finally block as cleanup is handled in callbacks now.
  // finally {
  //   // 6. Clean up temporary directory - MOVED
  // }
});
// --- END NEW ENDPOINT ---

// Start the server
app.listen(port, () => {
  console.log(`Backend server running on port ${port}`);
});
